<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta name="author" content="Matus Chochlik"/>
<meta name="copyright" content="Copyright 2015-2021 Matus Chochlik"/>
<meta name="keywords" content="C++ EGL OpenGL OpenAL Graphics Rendering"/>
<meta name="description" content="C++ wrapper for rendering C APIs"/>
<title>Memory utilities</title>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="oglplus.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="oglplus-frame">
<div id="oglplus-bar">
	<div id="oglplus-top">
	<div id="oglplus-top-content">
		<div id="oglplus-caption">
	   		<div id="oglplus-brief">
					<span id="oglplus-name">OGLplus&#160;</span>
					<span id="oglplus-version">(0.59.0)</span> a C++ wrapper for rendering APIs
				</div>
		</div>
		<hr/>
	</div>
	</div>
	<div id="oglplus-icon">
		<a href="http://oglplus.org/"><img src="../oglplus_circular.png"/></a>
	</div>
</div>
<div id="oglplus-content">
<div id="top">
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Memory utilities</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">eagine::memory::basic_address&lt; IsConst &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for handling memory addresses as integer values.  <a href="classeagine_1_1memory_1_1basic__address.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1aligned__block.html">eagine::memory::aligned_block&lt; Size &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class containing store of the specified size convertible to block.  <a href="classeagine_1_1memory_1_1aligned__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1owned__block.html">eagine::memory::owned_block</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of block indicating byte span ownership.  <a href="classeagine_1_1memory_1_1owned__block.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1block__owner.html">eagine::memory::block_owner</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class for classes that act as memory block owners.  <a href="classeagine_1_1memory_1_1block__owner.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1buffer.html">eagine::memory::buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reallocatable owning byte buffer.  <a href="classeagine_1_1memory_1_1buffer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1buffer__pool.html">eagine::memory::buffer_pool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class storing multiple reusable memory buffer instances.  <a href="classeagine_1_1memory_1_1buffer__pool.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">eagine::memory::basic_offset_ptr&lt; Pointee, OffsetType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic offset pointer class template.  <a href="classeagine_1_1memory_1_1basic__offset__ptr.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classeagine_1_1memory_1_1basic__split__span.html">eagine::memory::basic_split_span&lt; ValueType, Pointer, SizeType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template for classes representing a memory span split in two parts.  <a href="classeagine_1_1memory_1_1basic__split__span.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="memItemLeft" align="right" valign="top"><a id="gac012f79ffaff88e2f2ebeb2ab9cf4709"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">eagine::memory::const_address</a> = <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; true &gt;</td></tr>
<tr class="memdesc:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for const memory address values. <br /></td></tr>
<tr class="separator:gac012f79ffaff88e2f2ebeb2ab9cf4709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62558a22bf49982834d2fc9d56aa4a48"><td class="memItemLeft" align="right" valign="top"><a id="ga62558a22bf49982834d2fc9d56aa4a48"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga62558a22bf49982834d2fc9d56aa4a48">eagine::memory::address</a> = <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga62558a22bf49982834d2fc9d56aa4a48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for non-const memory address values. <br /></td></tr>
<tr class="separator:ga62558a22bf49982834d2fc9d56aa4a48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5dd5ce1a14209336eb031bc930d736f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">eagine::memory::block</a> = <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga5dd5ce1a14209336eb031bc930d736f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for non-const byte memory span.  <a href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">More...</a><br /></td></tr>
<tr class="separator:ga5dd5ce1a14209336eb031bc930d736f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9abe6f67096b87cac1c3116a66379971"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">eagine::memory::const_block</a> = <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; true &gt;</td></tr>
<tr class="memdesc:ga9abe6f67096b87cac1c3116a66379971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for const byte memory span.  <a href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">More...</a><br /></td></tr>
<tr class="separator:ga9abe6f67096b87cac1c3116a66379971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06677f578748e6082e4f2c80ac628e51"><td class="memTemplParams" colspan="2"><a id="ga06677f578748e6082e4f2c80ac628e51"></a>
template&lt;typename Pointee &gt; </td></tr>
<tr class="memitem:ga06677f578748e6082e4f2c80ac628e51"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga06677f578748e6082e4f2c80ac628e51">eagine::memory::offset_ptr</a> = <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; Pointee, std::ptrdiff_t &gt;</td></tr>
<tr class="memdesc:ga06677f578748e6082e4f2c80ac628e51"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default type alias for basic offset pointer. <br /></td></tr>
<tr class="separator:ga06677f578748e6082e4f2c80ac628e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memTemplParams" colspan="2"><a id="ga1d6e361736e3af8e290d01ff4cce3f8c"></a>
template&lt;typename Pointee &gt; </td></tr>
<tr class="memitem:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1d6e361736e3af8e290d01ff4cce3f8c">eagine::memory::short_offset_ptr</a> = <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; Pointee, short &gt;</td></tr>
<tr class="memdesc:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type alias for basic offset pointer with short offset. <br /></td></tr>
<tr class="separator:ga1d6e361736e3af8e290d01ff4cce3f8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memTemplParams" colspan="2"><a id="gac9f410f4f987f538a32f3dfaa16357ce"></a>
template&lt;typename T , typename O  = span_size_t, typename S  = span_size_t&gt; </td></tr>
<tr class="memitem:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac9f410f4f987f538a32f3dfaa16357ce">eagine::memory::basic_offset_span</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; T, O &gt;, S &gt;</td></tr>
<tr class="memdesc:gac9f410f4f987f538a32f3dfaa16357ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic alias for <a class="el" href="classeagine_1_1memory_1_1basic__span.html" title="Non-owning view of a contiguous range of memory with ValueType elements.">basic_span</a> with basic_offset_pointer. <br /></td></tr>
<tr class="separator:gac9f410f4f987f538a32f3dfaa16357ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memTemplParams" colspan="2"><a id="ga10a8de3b337fbad8d2b789962564ff6e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga10a8de3b337fbad8d2b789962564ff6e">eagine::memory::offset_span</a> = <a class="el" href="group__memory.html#gac9f410f4f987f538a32f3dfaa16357ce">basic_offset_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga10a8de3b337fbad8d2b789962564ff6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for basic_offset_span. <br /></td></tr>
<tr class="separator:ga10a8de3b337fbad8d2b789962564ff6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad51eebf35c26db72a8735cf80a569099"><td class="memTemplParams" colspan="2"><a id="gad51eebf35c26db72a8735cf80a569099"></a>
template&lt;typename T , typename S  = span_size_t&gt; </td></tr>
<tr class="memitem:gad51eebf35c26db72a8735cf80a569099"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">eagine::memory::span</a> = <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, T *, S &gt;</td></tr>
<tr class="memdesc:gad51eebf35c26db72a8735cf80a569099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default alias for basic memory spans with native pointer type. <br /></td></tr>
<tr class="separator:gad51eebf35c26db72a8735cf80a569099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga894d4cf6e581395b9212297f1f66b538"><td class="memTemplParams" colspan="2"><a id="ga894d4cf6e581395b9212297f1f66b538"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga894d4cf6e581395b9212297f1f66b538"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">eagine::memory::span_if_mutable</a> = std::enable_if_t&lt;!std::is_const_v&lt; T &gt;, <a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">span</a>&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga894d4cf6e581395b9212297f1f66b538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for span&lt;T&gt; if T is mutable type. Ill defined otherwise. <br /></td></tr>
<tr class="separator:ga894d4cf6e581395b9212297f1f66b538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memTemplParams" colspan="2"><a id="ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">eagine::memory::const_span</a> = <a class="el" href="group__memory.html#gad51eebf35c26db72a8735cf80a569099">span</a>&lt; std::add_const_t&lt; T &gt; &gt;</td></tr>
<tr class="memdesc:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for spans with const element type. <br /></td></tr>
<tr class="separator:ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d90edae2138d5bfebc1e06008530821"><td class="memItemLeft" align="right" valign="top"><a id="ga7d90edae2138d5bfebc1e06008530821"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7d90edae2138d5bfebc1e06008530821">eagine::memory::split_block</a> = <a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">basic_split_block</a>&lt; false &gt;</td></tr>
<tr class="memdesc:ga7d90edae2138d5bfebc1e06008530821"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for non-const split blocks. <br /></td></tr>
<tr class="separator:ga7d90edae2138d5bfebc1e06008530821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="memItemLeft" align="right" valign="top"><a id="gaf559dcbcc620d163248b4034f0d3c7c8"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf559dcbcc620d163248b4034f0d3c7c8">eagine::memory::const_split_block</a> = <a class="el" href="group__type__utils.html#gadbd294528813ac25d56decb0e5194089">basic_split_block</a>&lt; true &gt;</td></tr>
<tr class="memdesc:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alias for const split blocks. <br /></td></tr>
<tr class="separator:gaf559dcbcc620d163248b4034f0d3c7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga3a17060222729d5624485ee2c7d08a5a"><td class="memTemplParams" colspan="2"><a id="ga3a17060222729d5624485ee2c7d08a5a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga3a17060222729d5624485ee2c7d08a5a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3a17060222729d5624485ee2c7d08a5a">eagine::memory::as_address</a> (T *addr) noexcept</td></tr>
<tr class="memdesc:ga3a17060222729d5624485ee2c7d08a5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Casts a pointer to <a class="el" href="classeagine_1_1memory_1_1basic__address.html" title="Class for handling memory addresses as integer values.">basic_address</a>. <br /></td></tr>
<tr class="separator:ga3a17060222729d5624485ee2c7d08a5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaabf25547abd7741b3c9d76f6c232ba91"><td class="memItemLeft" align="right" valign="top"><a id="gaabf25547abd7741b3c9d76f6c232ba91"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gaabf25547abd7741b3c9d76f6c232ba91">eagine::memory::misalignment</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:gaabf25547abd7741b3c9d76f6c232ba91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the misalignment of a memory address to the specified alignment. <br /></td></tr>
<tr class="separator:gaabf25547abd7741b3c9d76f6c232ba91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78a71fe5bae5ac72035d0c637099a0f9"><td class="memItemLeft" align="right" valign="top"><a id="ga78a71fe5bae5ac72035d0c637099a0f9"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga78a71fe5bae5ac72035d0c637099a0f9">eagine::memory::misalignment</a> (const void *ptr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:ga78a71fe5bae5ac72035d0c637099a0f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the misalignment of a pointer to the specified alignment. <br /></td></tr>
<tr class="separator:ga78a71fe5bae5ac72035d0c637099a0f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe066962c41f68a5d4cf507af2bb7d9a"><td class="memItemLeft" align="right" valign="top"><a id="gabe066962c41f68a5d4cf507af2bb7d9a"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gabe066962c41f68a5d4cf507af2bb7d9a">eagine::memory::is_aligned_to</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:gabe066962c41f68a5d4cf507af2bb7d9a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a memory address aligned to the specified alignment. <br /></td></tr>
<tr class="separator:gabe066962c41f68a5d4cf507af2bb7d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69e1ffbd29c674e1a3219dd3dc89705f"><td class="memItemLeft" align="right" valign="top"><a id="ga69e1ffbd29c674e1a3219dd3dc89705f"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga69e1ffbd29c674e1a3219dd3dc89705f">eagine::memory::is_aligned_to</a> (const void *ptr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept</td></tr>
<tr class="memdesc:ga69e1ffbd29c674e1a3219dd3dc89705f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a pointer is aligned to the specified alignment. <br /></td></tr>
<tr class="separator:ga69e1ffbd29c674e1a3219dd3dc89705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d12e54f4d5ed6a0374450f69acac041"><td class="memTemplParams" colspan="2"><a id="ga0d12e54f4d5ed6a0374450f69acac041"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga0d12e54f4d5ed6a0374450f69acac041"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0d12e54f4d5ed6a0374450f69acac041">eagine::memory::is_aligned_as</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept</td></tr>
<tr class="memdesc:ga0d12e54f4d5ed6a0374450f69acac041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a memory address aligned as the specified type T. <br /></td></tr>
<tr class="separator:ga0d12e54f4d5ed6a0374450f69acac041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa85bb51167cba2b89aa607f12570e53e"><td class="memTemplParams" colspan="2">template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gaa85bb51167cba2b89aa607f12570e53e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa85bb51167cba2b89aa607f12570e53e">eagine::memory::align_up</a> (<a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;</td></tr>
<tr class="memdesc:gaa85bb51167cba2b89aa607f12570e53e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address up to the specified alignment.  <a href="group__memory.html#gaa85bb51167cba2b89aa607f12570e53e">More...</a><br /></td></tr>
<tr class="separator:gaa85bb51167cba2b89aa607f12570e53e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb580346318713fe3ea7a3394adf1b0b"><td class="memTemplParams" colspan="2">template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:gabb580346318713fe3ea7a3394adf1b0b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gabb580346318713fe3ea7a3394adf1b0b">eagine::memory::align_down</a> (<a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;</td></tr>
<tr class="memdesc:gabb580346318713fe3ea7a3394adf1b0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the specified alignment.  <a href="group__memory.html#gabb580346318713fe3ea7a3394adf1b0b">More...</a><br /></td></tr>
<tr class="separator:gabb580346318713fe3ea7a3394adf1b0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga164d5d4556d0a4fbeb603f9089502299"><td class="memTemplParams" colspan="2"><a id="ga164d5d4556d0a4fbeb603f9089502299"></a>
template&lt;bool IsConst&gt; </td></tr>
<tr class="memitem:ga164d5d4556d0a4fbeb603f9089502299"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga164d5d4556d0a4fbeb603f9089502299">eagine::memory::align_down</a> (<a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt; addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align) noexcept</td></tr>
<tr class="memdesc:ga164d5d4556d0a4fbeb603f9089502299"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the specified alignment. <br /></td></tr>
<tr class="separator:ga164d5d4556d0a4fbeb603f9089502299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga43d08f07f68f72dd02905abbc3c70502"><td class="memItemLeft" align="right" valign="top"><a id="ga43d08f07f68f72dd02905abbc3c70502"></a>
static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga43d08f07f68f72dd02905abbc3c70502">eagine::memory::align_down</a> (const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> *ptr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align) -&gt; const <a class="el" href="group__type__utils.html#ga973e3bb89ea2c57a0e9204e9ffc0167e">byte</a> *</td></tr>
<tr class="memdesc:ga43d08f07f68f72dd02905abbc3c70502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a byte pointer down to the specified alignment. <br /></td></tr>
<tr class="separator:ga43d08f07f68f72dd02905abbc3c70502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8858b4badb595974db9980837d2d250f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga8858b4badb595974db9980837d2d250f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8858b4badb595974db9980837d2d250f">eagine::memory::align_up_to</a> (<a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt; addr, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align=<a class="el" href="group__type__utils.html#gaab46da9ac6255df6ca55cba220c61794">span_align_of</a>&lt; T &gt;(), <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max=<a class="el" href="group__type__utils.html#gaedb51bc925f4e93cf94a96b25dce1bf4">span_size_of</a>&lt; T &gt;()) noexcept</td></tr>
<tr class="memdesc:ga8858b4badb595974db9980837d2d250f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address up to the required alignment of type T.  <a href="group__memory.html#ga8858b4badb595974db9980837d2d250f">More...</a><br /></td></tr>
<tr class="separator:ga8858b4badb595974db9980837d2d250f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade92d5b382a2aa1e8b509c0af0f25c77"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:gade92d5b382a2aa1e8b509c0af0f25c77"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gade92d5b382a2aa1e8b509c0af0f25c77">eagine::memory::align_down_to</a> (<a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt; addr, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> align=<a class="el" href="group__type__utils.html#gaab46da9ac6255df6ca55cba220c61794">span_align_of</a>&lt; T &gt;(), <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> max=<a class="el" href="group__type__utils.html#gaedb51bc925f4e93cf94a96b25dce1bf4">span_size_of</a>&lt; T &gt;()) noexcept</td></tr>
<tr class="memdesc:gade92d5b382a2aa1e8b509c0af0f25c77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aligns a memory address down to the required alignment of type T.  <a href="group__memory.html#gade92d5b382a2aa1e8b509c0af0f25c77">More...</a><br /></td></tr>
<tr class="separator:gade92d5b382a2aa1e8b509c0af0f25c77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89e7eb9bd1d8887794e93dbb8f4ab429"><td class="memItemLeft" align="right" valign="top"><a id="ga89e7eb9bd1d8887794e93dbb8f4ab429"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga89e7eb9bd1d8887794e93dbb8f4ab429">eagine::memory::misalignment</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> alignment) noexcept -&gt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a></td></tr>
<tr class="memdesc:ga89e7eb9bd1d8887794e93dbb8f4ab429"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates basic numeric address misalignment. <br /></td></tr>
<tr class="separator:ga89e7eb9bd1d8887794e93dbb8f4ab429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac2e9b42edbd663141f50fab9f0a69db5"><td class="memItemLeft" align="right" valign="top"><a id="gac2e9b42edbd663141f50fab9f0a69db5"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#gac2e9b42edbd663141f50fab9f0a69db5">eagine::memory::misalignment</a> (std::nullptr_t, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>) noexcept -&gt; <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a></td></tr>
<tr class="memdesc:gac2e9b42edbd663141f50fab9f0a69db5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates basic numeric address misalignment. <br /></td></tr>
<tr class="separator:gac2e9b42edbd663141f50fab9f0a69db5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62c40b3dd594395fdfb668c87297712e"><td class="memItemLeft" align="right" valign="top"><a id="ga62c40b3dd594395fdfb668c87297712e"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga62c40b3dd594395fdfb668c87297712e">eagine::memory::is_aligned_to</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> algn) noexcept</td></tr>
<tr class="memdesc:ga62c40b3dd594395fdfb668c87297712e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned. <br /></td></tr>
<tr class="separator:ga62c40b3dd594395fdfb668c87297712e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4845638db9bf33e6132dd326dc3cab3f"><td class="memItemLeft" align="right" valign="top"><a id="ga4845638db9bf33e6132dd326dc3cab3f"></a>
static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4845638db9bf33e6132dd326dc3cab3f">eagine::memory::is_aligned_to</a> (std::nullptr_t, <a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>) noexcept</td></tr>
<tr class="memdesc:ga4845638db9bf33e6132dd326dc3cab3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned. <br /></td></tr>
<tr class="separator:ga4845638db9bf33e6132dd326dc3cab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fc13f3dd0ff5a3b6a35a0c0653c0e"><td class="memTemplParams" colspan="2"><a id="gae64fc13f3dd0ff5a3b6a35a0c0653c0e"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gae64fc13f3dd0ff5a3b6a35a0c0653c0e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae64fc13f3dd0ff5a3b6a35a0c0653c0e">eagine::memory::is_aligned_as</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> addr, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;={}) noexcept</td></tr>
<tr class="memdesc:gae64fc13f3dd0ff5a3b6a35a0c0653c0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a basic numeric address is aligned to alignment of type T. <br /></td></tr>
<tr class="separator:gae64fc13f3dd0ff5a3b6a35a0c0653c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74ce9ca5ad1a664db09d395022179f3b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga74ce9ca5ad1a664db09d395022179f3b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga74ce9ca5ad1a664db09d395022179f3b">eagine::memory::as_bytes</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt; std::is_const_v&lt; T &gt;&gt;</td></tr>
<tr class="memdesc:ga74ce9ca5ad1a664db09d395022179f3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a span into a basic_block.  <a href="group__memory.html#ga74ce9ca5ad1a664db09d395022179f3b">More...</a><br /></td></tr>
<tr class="separator:ga74ce9ca5ad1a664db09d395022179f3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga09b22ac988a3d779f428c3e461cc2ccf"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga09b22ac988a3d779f428c3e461cc2ccf">eagine::memory::as_chars</a> (<a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> blk) noexcept</td></tr>
<tr class="memdesc:ga09b22ac988a3d779f428c3e461cc2ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a block into a span of characters.  <a href="group__memory.html#ga09b22ac988a3d779f428c3e461cc2ccf">More...</a><br /></td></tr>
<tr class="separator:ga09b22ac988a3d779f428c3e461cc2ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga75034d39aa1ee61d725905a3b3d33a90"><td class="memItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga75034d39aa1ee61d725905a3b3d33a90">eagine::memory::as_chars</a> (<a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> blk) noexcept</td></tr>
<tr class="memdesc:ga75034d39aa1ee61d725905a3b3d33a90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a block into a span of characters.  <a href="group__memory.html#ga75034d39aa1ee61d725905a3b3d33a90">More...</a><br /></td></tr>
<tr class="separator:ga75034d39aa1ee61d725905a3b3d33a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a9fddc58451ef62a96bc9d3fadfb011"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4a9fddc58451ef62a96bc9d3fadfb011">eagine::memory::copy</a> (<a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> source, <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> dest) -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a></td></tr>
<tr class="memdesc:ga4a9fddc58451ef62a96bc9d3fadfb011"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of source block to destination block.  <a href="group__memory.html#ga4a9fddc58451ef62a96bc9d3fadfb011">More...</a><br /></td></tr>
<tr class="separator:ga4a9fddc58451ef62a96bc9d3fadfb011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga975d696b679b6918b61e8333c82bfeda"><td class="memItemLeft" align="right" valign="top">static auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__memory.html#ga975d696b679b6918b61e8333c82bfeda">eagine::memory::copy_into</a> (<a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a> source, <a class="el" href="classeagine_1_1memory_1_1buffer.html">buffer</a> &amp;dest) -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a></td></tr>
<tr class="memdesc:ga975d696b679b6918b61e8333c82bfeda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the content of source block to destination buffer.  <a href="group__memory.html#ga975d696b679b6918b61e8333c82bfeda">More...</a><br /></td></tr>
<tr class="separator:ga975d696b679b6918b61e8333c82bfeda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memTemplParams" colspan="2"><a id="gaf32e12e4506d0ac5ffa26397d3140ffa"></a>
template&lt;typename P , typename O &gt; </td></tr>
<tr class="memitem:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaf32e12e4506d0ac5ffa26397d3140ffa">eagine::memory::as_address</a> (<a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; P, O &gt; op) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; P &gt;&gt;</td></tr>
<tr class="memdesc:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html" title="Basic offset pointer class template.">basic_offset_ptr</a> into <a class="el" href="classeagine_1_1memory_1_1basic__address.html" title="Class for handling memory addresses as integer values.">basic_address</a>. <br /></td></tr>
<tr class="separator:gaf32e12e4506d0ac5ffa26397d3140ffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gadd2bd8629c6e69e1b9ee40ad72e61876">eagine::memory::relative</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt; T, std::make_signed_t&lt; S &gt;&gt;, S &gt;</td></tr>
<tr class="memdesc:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span using an offset pointer type.  <a href="group__memory.html#gadd2bd8629c6e69e1b9ee40ad72e61876">More...</a><br /></td></tr>
<tr class="separator:gadd2bd8629c6e69e1b9ee40ad72e61876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90527c44f086ae0f31578270c117d149"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga90527c44f086ae0f31578270c117d149"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga90527c44f086ae0f31578270c117d149">eagine::memory::absolute</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, T *, S &gt;</td></tr>
<tr class="memdesc:ga90527c44f086ae0f31578270c117d149"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts argument to span using a native pointer type.  <a href="group__memory.html#ga90527c44f086ae0f31578270c117d149">More...</a><br /></td></tr>
<tr class="separator:ga90527c44f086ae0f31578270c117d149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa1c38aab41b4986aa356cee68a658c79"><td class="memTemplParams" colspan="2"><a id="gaa1c38aab41b4986aa356cee68a658c79"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:gaa1c38aab41b4986aa356cee68a658c79"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa1c38aab41b4986aa356cee68a658c79">eagine::memory::view_one</a> (const T &amp;value) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gaa1c38aab41b4986aa356cee68a658c79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-const-element view over the specified value. <br /></td></tr>
<tr class="separator:gaa1c38aab41b4986aa356cee68a658c79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memTemplParams" colspan="2"><a id="ga4c24b3a8932dad93aa92ec7c7da67436"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4c24b3a8932dad93aa92ec7c7da67436">eagine::memory::cover_one</a> (T &amp;value) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-element mutable span over the specified value. <br /></td></tr>
<tr class="separator:ga4c24b3a8932dad93aa92ec7c7da67436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6258fd8a67a0544bec4355c9909a299a"><td class="memTemplParams" colspan="2"><a id="ga6258fd8a67a0544bec4355c9909a299a"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga6258fd8a67a0544bec4355c9909a299a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6258fd8a67a0544bec4355c9909a299a">eagine::memory::view_one</a> (const T *pointer) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga6258fd8a67a0544bec4355c9909a299a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-const-element view from the specified pointer. <br /></td></tr>
<tr class="separator:ga6258fd8a67a0544bec4355c9909a299a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52128e793163289fdbb62ac544cd1fcd"><td class="memTemplParams" colspan="2"><a id="ga52128e793163289fdbb62ac544cd1fcd"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga52128e793163289fdbb62ac544cd1fcd"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga52128e793163289fdbb62ac544cd1fcd">eagine::memory::cover_one</a> (T *pointer) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga52128e793163289fdbb62ac544cd1fcd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a single-element mutable span from the specified pointer. <br /></td></tr>
<tr class="separator:ga52128e793163289fdbb62ac544cd1fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga088bd49cb9bc7cf74b5f54d6437dcaed"><td class="memTemplParams" colspan="2"><a id="ga088bd49cb9bc7cf74b5f54d6437dcaed"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga088bd49cb9bc7cf74b5f54d6437dcaed"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga088bd49cb9bc7cf74b5f54d6437dcaed">eagine::memory::view</a> (T *addr, S size) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga088bd49cb9bc7cf74b5f54d6437dcaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view starting at the specified pointer and specified length. <br /></td></tr>
<tr class="separator:ga088bd49cb9bc7cf74b5f54d6437dcaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42cf5a6ab3fa34eee7b8a58cf4233306"><td class="memTemplParams" colspan="2"><a id="ga42cf5a6ab3fa34eee7b8a58cf4233306"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga42cf5a6ab3fa34eee7b8a58cf4233306"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga42cf5a6ab3fa34eee7b8a58cf4233306">eagine::memory::cover</a> (T *addr, S size) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga42cf5a6ab3fa34eee7b8a58cf4233306"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span starting at the specified pointer and specified length. <br /></td></tr>
<tr class="separator:ga42cf5a6ab3fa34eee7b8a58cf4233306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf0e9db72df3406b30a224a320328f96"><td class="memTemplParams" colspan="2"><a id="gadf0e9db72df3406b30a224a320328f96"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:gadf0e9db72df3406b30a224a320328f96"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gadf0e9db72df3406b30a224a320328f96">eagine::memory::view</a> (<a class="el" href="group__memory.html#gac012f79ffaff88e2f2ebeb2ab9cf4709">const_address</a> addr, S size) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gadf0e9db72df3406b30a224a320328f96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a view starting at the specified address and specified length. <br /></td></tr>
<tr class="separator:gadf0e9db72df3406b30a224a320328f96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3de89d72f42c48581440f549d2b592f0"><td class="memTemplParams" colspan="2"><a id="ga3de89d72f42c48581440f549d2b592f0"></a>
template&lt;typename T , typename S &gt; </td></tr>
<tr class="memitem:ga3de89d72f42c48581440f549d2b592f0"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3de89d72f42c48581440f549d2b592f0">eagine::memory::cover</a> (<a class="el" href="group__memory.html#ga62558a22bf49982834d2fc9d56aa4a48">address</a> addr, S size) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga3de89d72f42c48581440f549d2b592f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a span starting at the specified address and specified length. <br /></td></tr>
<tr class="separator:ga3de89d72f42c48581440f549d2b592f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memTemplParams" colspan="2"><a id="ga4a65df5e51410fde4984224f8dfbd25a"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4a65df5e51410fde4984224f8dfbd25a">eagine::memory::view</a> (const T(&amp;array)[N]) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga4a65df5e51410fde4984224f8dfbd25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over the specified fixed-size array. <br /></td></tr>
<tr class="separator:ga4a65df5e51410fde4984224f8dfbd25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9fa13ff28cf204b49336f60740f86da"><td class="memTemplParams" colspan="2"><a id="gae9fa13ff28cf204b49336f60740f86da"></a>
template&lt;typename T , std::size_t N&gt; </td></tr>
<tr class="memitem:gae9fa13ff28cf204b49336f60740f86da"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae9fa13ff28cf204b49336f60740f86da">eagine::memory::cover</a> (T(&amp;array)[N]) noexcept -&gt; <a class="el" href="group__memory.html#ga894d4cf6e581395b9212297f1f66b538">span_if_mutable</a>&lt; T &gt;</td></tr>
<tr class="memdesc:gae9fa13ff28cf204b49336f60740f86da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutable span covering the specified fixed-size array. <br /></td></tr>
<tr class="separator:gae9fa13ff28cf204b49336f60740f86da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memTemplParams" colspan="2"><a id="ga19f9278cf40fbc76cbfbb04be0c29667"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga19f9278cf40fbc76cbfbb04be0c29667">eagine::memory::view</a> (std::initializer_list&lt; T &gt; il) noexcept -&gt; <a class="el" href="group__memory.html#ga2cc4254a54f3e00a5e8a0a1a2f3ddc3e">const_span</a>&lt; T &gt;</td></tr>
<tr class="memdesc:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over the specified initializer list. <br /></td></tr>
<tr class="separator:ga19f9278cf40fbc76cbfbb04be0c29667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga542ae28cfa38ce0ac7665c91a9b1859c"><td class="memTemplParams" colspan="2"><a id="ga542ae28cfa38ce0ac7665c91a9b1859c"></a>
template&lt;typename C , typename  = std::enable_if_t&lt;has_span_data_member_v&lt;C&gt; &amp;&amp; has_span_size_member_v&lt;C&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga542ae28cfa38ce0ac7665c91a9b1859c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga542ae28cfa38ce0ac7665c91a9b1859c">eagine::memory::view</a> (const C &amp;container) noexcept</td></tr>
<tr class="memdesc:ga542ae28cfa38ce0ac7665c91a9b1859c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a const view over a compatible contiguous container. <br /></td></tr>
<tr class="separator:ga542ae28cfa38ce0ac7665c91a9b1859c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cea095fc8303a934afdc64dd2eafe40"><td class="memTemplParams" colspan="2"><a id="ga3cea095fc8303a934afdc64dd2eafe40"></a>
template&lt;typename C , typename  = std::enable_if_t&lt;has_span_data_member_v&lt;C&gt; &amp;&amp; has_span_size_member_v&lt;C&gt;&gt;&gt; </td></tr>
<tr class="memitem:ga3cea095fc8303a934afdc64dd2eafe40"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3cea095fc8303a934afdc64dd2eafe40">eagine::memory::cover</a> (C &amp;container) noexcept</td></tr>
<tr class="memdesc:ga3cea095fc8303a934afdc64dd2eafe40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a mutable span covering a compatible contiguous container. <br /></td></tr>
<tr class="separator:ga3cea095fc8303a934afdc64dd2eafe40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga90909590e59d12c65c69564051d53424"><td class="memTemplParams" colspan="2">template&lt;typename T , typename B , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga90909590e59d12c65c69564051d53424"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga90909590e59d12c65c69564051d53424">eagine::memory::accomodate</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt; blk, <a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt; tid={}) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; std::add_const_t&lt; T &gt;, rebind_pointer_t&lt; P, T &gt;, S &gt;</td></tr>
<tr class="memdesc:ga90909590e59d12c65c69564051d53424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a span, rebinding the element type (typically from basic_block).  <a href="group__memory.html#ga90909590e59d12c65c69564051d53424">More...</a><br /></td></tr>
<tr class="separator:ga90909590e59d12c65c69564051d53424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05e741e072a75182869ff2c0cfbb83be"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga05e741e072a75182869ff2c0cfbb83be"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga05e741e072a75182869ff2c0cfbb83be">eagine::memory::extract</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:ga05e741e072a75182869ff2c0cfbb83be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of extract for spans. Returns the first element,.  <a href="group__memory.html#ga05e741e072a75182869ff2c0cfbb83be">More...</a><br /></td></tr>
<tr class="separator:ga05e741e072a75182869ff2c0cfbb83be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cf1368f3fe9d29ef9d187feaeb220b4"><td class="memTemplParams" colspan="2"><a id="ga5cf1368f3fe9d29ef9d187feaeb220b4"></a>
template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga5cf1368f3fe9d29ef9d187feaeb220b4"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5cf1368f3fe9d29ef9d187feaeb220b4">eagine::memory::extract_or</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, T &amp;fallback) noexcept -&gt; T &amp;</td></tr>
<tr class="memdesc:ga5cf1368f3fe9d29ef9d187feaeb220b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of extract_or for spans. Returns the first element,. <br /></td></tr>
<tr class="separator:ga5cf1368f3fe9d29ef9d187feaeb220b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8"><td class="memTemplParams" colspan="2"><a id="ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8"></a>
template&lt;typename T , typename P , typename S , typename F &gt; </td></tr>
<tr class="memitem:ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8">eagine::memory::extract_or</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, F &amp;&amp;fallback) -&gt; std::enable_if_t&lt; std::is_convertible_v&lt; F, T &gt;, T &gt;</td></tr>
<tr class="memdesc:ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload of extract_or for spans. Returns the first element,. <br /></td></tr>
<tr class="separator:ga7ff6ed1ad9a7b1f5ac20d2c1af4463a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacf535a58f631ee947e5835f5a4dc5e19"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename L &gt; </td></tr>
<tr class="memitem:gacf535a58f631ee947e5835f5a4dc5e19"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gacf535a58f631ee947e5835f5a4dc5e19">eagine::memory::slice</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, I i, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gacf535a58f631ee947e5835f5a4dc5e19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span starting at specified index with specified length.  <a href="group__memory.html#gacf535a58f631ee947e5835f5a4dc5e19">More...</a><br /></td></tr>
<tr class="separator:gacf535a58f631ee947e5835f5a4dc5e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga043f365df2ad028630a9db3b699e9a9c"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:ga043f365df2ad028630a9db3b699e9a9c"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga043f365df2ad028630a9db3b699e9a9c">eagine::memory::skip</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga043f365df2ad028630a9db3b699e9a9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips a specified count of elements from the front of a span.  <a href="group__memory.html#ga043f365df2ad028630a9db3b699e9a9c">More...</a><br /></td></tr>
<tr class="separator:ga043f365df2ad028630a9db3b699e9a9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaccf80c25c79b01fe71ec07170cee083"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:gaaccf80c25c79b01fe71ec07170cee083"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaaccf80c25c79b01fe71ec07170cee083">eagine::memory::snip</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gaaccf80c25c79b01fe71ec07170cee083"><td class="mdescLeft">&#160;</td><td class="mdescRight">Snips a specified count of elements from the back of a span.  <a href="group__memory.html#gaaccf80c25c79b01fe71ec07170cee083">More...</a><br /></td></tr>
<tr class="separator:gaaccf80c25c79b01fe71ec07170cee083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga001c145b85d45759647de6a1013c35b7"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:ga001c145b85d45759647de6a1013c35b7"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga001c145b85d45759647de6a1013c35b7">eagine::memory::shrink</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga001c145b85d45759647de6a1013c35b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shrinks a span by removing a specified count of elements from both sides.  <a href="group__memory.html#ga001c145b85d45759647de6a1013c35b7">More...</a><br /></td></tr>
<tr class="separator:ga001c145b85d45759647de6a1013c35b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32f48e6dee85c700216be2c57834de9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:gac32f48e6dee85c700216be2c57834de9"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac32f48e6dee85c700216be2c57834de9">eagine::memory::head</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gac32f48e6dee85c700216be2c57834de9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first <code>l</code> elements from the front of a span.  <a href="group__memory.html#gac32f48e6dee85c700216be2c57834de9">More...</a><br /></td></tr>
<tr class="separator:gac32f48e6dee85c700216be2c57834de9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga685dcc8870589231d3f43f2b4553230e"><td class="memTemplParams" colspan="2">template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </td></tr>
<tr class="memitem:ga685dcc8870589231d3f43f2b4553230e"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga685dcc8870589231d3f43f2b4553230e">eagine::memory::head</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt; s, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt; l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;</td></tr>
<tr class="memdesc:ga685dcc8870589231d3f43f2b4553230e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the head of <code>s</code> l.size() elements long.  <a href="group__memory.html#ga685dcc8870589231d3f43f2b4553230e">More...</a><br /></td></tr>
<tr class="separator:ga685dcc8870589231d3f43f2b4553230e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10e323de0d244d2aa0760ce092d16478"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename L &gt; </td></tr>
<tr class="memitem:ga10e323de0d244d2aa0760ce092d16478"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga10e323de0d244d2aa0760ce092d16478">eagine::memory::tail</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; s, L l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga10e323de0d244d2aa0760ce092d16478"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the last <code>l</code> elements from the back of a span.  <a href="group__memory.html#ga10e323de0d244d2aa0760ce092d16478">More...</a><br /></td></tr>
<tr class="separator:ga10e323de0d244d2aa0760ce092d16478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7802c35f2ff0bc4988d707ea0fdf4e56"><td class="memTemplParams" colspan="2">template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </td></tr>
<tr class="memitem:ga7802c35f2ff0bc4988d707ea0fdf4e56"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7802c35f2ff0bc4988d707ea0fdf4e56">eagine::memory::tail</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt; s, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt; l) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;</td></tr>
<tr class="memdesc:ga7802c35f2ff0bc4988d707ea0fdf4e56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the tail of <code>s</code> l.size() elements long.  <a href="group__memory.html#ga7802c35f2ff0bc4988d707ea0fdf4e56">More...</a><br /></td></tr>
<tr class="separator:ga7802c35f2ff0bc4988d707ea0fdf4e56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b6c48e81631ada4a7d63cf0186814a3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga5b6c48e81631ada4a7d63cf0186814a3"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga5b6c48e81631ada4a7d63cf0186814a3">eagine::memory::starts_with</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; with) -&gt; bool</td></tr>
<tr class="memdesc:ga5b6c48e81631ada4a7d63cf0186814a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if span <code>spn</code> starts with the content of <code>with</code>.  <a href="group__memory.html#ga5b6c48e81631ada4a7d63cf0186814a3">More...</a><br /></td></tr>
<tr class="separator:ga5b6c48e81631ada4a7d63cf0186814a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac32ab0924bf65443c2264c4b882cf474"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gac32ab0924bf65443c2264c4b882cf474"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac32ab0924bf65443c2264c4b882cf474">eagine::memory::ends_with</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; with) -&gt; bool</td></tr>
<tr class="memdesc:gac32ab0924bf65443c2264c4b882cf474"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if span <code>spn</code> ends with the content of <code>with</code>.  <a href="group__memory.html#gac32ab0924bf65443c2264c4b882cf474">More...</a><br /></td></tr>
<tr class="separator:gac32ab0924bf65443c2264c4b882cf474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab18d064b092370605f7fad13b9b1bf73"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gab18d064b092370605f7fad13b9b1bf73"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gab18d064b092370605f7fad13b9b1bf73">eagine::memory::strip_prefix</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; prefix) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:gab18d064b092370605f7fad13b9b1bf73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the specified <code>prefix</code> from a span.  <a href="group__memory.html#gab18d064b092370605f7fad13b9b1bf73">More...</a><br /></td></tr>
<tr class="separator:gab18d064b092370605f7fad13b9b1bf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7857c935a23ecdf6544cf7e565098f"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga6a7857c935a23ecdf6544cf7e565098f"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6a7857c935a23ecdf6544cf7e565098f">eagine::memory::strip_suffix</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; suffix) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga6a7857c935a23ecdf6544cf7e565098f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strips the specified <code>suffix</code> from a span.  <a href="group__memory.html#ga6a7857c935a23ecdf6544cf7e565098f">More...</a><br /></td></tr>
<tr class="separator:ga6a7857c935a23ecdf6544cf7e565098f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga118ce06e388d17bfb743ed21a4ab62f8"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga118ce06e388d17bfb743ed21a4ab62f8"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga118ce06e388d17bfb743ed21a4ab62f8">eagine::memory::contains</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; S1</td></tr>
<tr class="memdesc:ga118ce06e388d17bfb743ed21a4ab62f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates if a span contains the contents of <code>what</code>.  <a href="group__memory.html#ga118ce06e388d17bfb743ed21a4ab62f8">More...</a><br /></td></tr>
<tr class="separator:ga118ce06e388d17bfb743ed21a4ab62f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb0bbcf75b8f7a1c90e5006aac386bb"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga3cb0bbcf75b8f7a1c90e5006aac386bb"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3cb0bbcf75b8f7a1c90e5006aac386bb">eagine::memory::find_position</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S1 &gt;</td></tr>
<tr class="memdesc:ga3cb0bbcf75b8f7a1c90e5006aac386bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga3cb0bbcf75b8f7a1c90e5006aac386bb">More...</a><br /></td></tr>
<tr class="separator:ga3cb0bbcf75b8f7a1c90e5006aac386bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7c8aa8f76aa003ce6a549f25025641dc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename E &gt; </td></tr>
<tr class="memitem:ga7c8aa8f76aa003ce6a549f25025641dc"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga7c8aa8f76aa003ce6a549f25025641dc">eagine::memory::find_element</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, E what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S &gt;</td></tr>
<tr class="memdesc:ga7c8aa8f76aa003ce6a549f25025641dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga7c8aa8f76aa003ce6a549f25025641dc">More...</a><br /></td></tr>
<tr class="separator:ga7c8aa8f76aa003ce6a549f25025641dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga736704005e11e09e06cef0faa10c1518"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename F &gt; </td></tr>
<tr class="memitem:ga736704005e11e09e06cef0faa10c1518"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga736704005e11e09e06cef0faa10c1518">eagine::memory::find_element_if</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, F predicate) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S &gt;</td></tr>
<tr class="memdesc:ga736704005e11e09e06cef0faa10c1518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the first element satisfying <code>predicate</code> in a span.  <a href="group__memory.html#ga736704005e11e09e06cef0faa10c1518">More...</a><br /></td></tr>
<tr class="separator:ga736704005e11e09e06cef0faa10c1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6f0570550eacf320c8a6c79504106966"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:ga6f0570550eacf320c8a6c79504106966"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6f0570550eacf320c8a6c79504106966">eagine::memory::skip_until</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga6f0570550eacf320c8a6c79504106966"><td class="mdescLeft">&#160;</td><td class="mdescRight">Skips the elements from the front of a span until <code>predicate</code> is satisfied.  <a href="group__memory.html#ga6f0570550eacf320c8a6c79504106966">More...</a><br /></td></tr>
<tr class="separator:ga6f0570550eacf320c8a6c79504106966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad662b6d4685ae624c3da06ba0dd7d48b"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Predicate &gt; </td></tr>
<tr class="memitem:gad662b6d4685ae624c3da06ba0dd7d48b"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad662b6d4685ae624c3da06ba0dd7d48b">eagine::memory::take_until</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Predicate predicate) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gad662b6d4685ae624c3da06ba0dd7d48b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes the elements from the front of a span until <code>predicate</code> is satisfied.  <a href="group__memory.html#gad662b6d4685ae624c3da06ba0dd7d48b">More...</a><br /></td></tr>
<tr class="separator:gad662b6d4685ae624c3da06ba0dd7d48b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3db554dceef2dcb97e9a95ecdf96d837"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga3db554dceef2dcb97e9a95ecdf96d837"><td class="memTemplItemLeft" align="right" valign="top">static constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3db554dceef2dcb97e9a95ecdf96d837">eagine::memory::reverse_find_position</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) noexcept -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt; S1 &gt;</td></tr>
<tr class="memdesc:ga3db554dceef2dcb97e9a95ecdf96d837"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the last occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga3db554dceef2dcb97e9a95ecdf96d837">More...</a><br /></td></tr>
<tr class="separator:ga3db554dceef2dcb97e9a95ecdf96d837"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3896cfd00446f4c179f8d4e9227248b9"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga3896cfd00446f4c179f8d4e9227248b9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga3896cfd00446f4c179f8d4e9227248b9">eagine::memory::find</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; where, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga3896cfd00446f4c179f8d4e9227248b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the position of the last occurrence of <code>what</code> in a span.  <a href="group__memory.html#ga3896cfd00446f4c179f8d4e9227248b9">More...</a><br /></td></tr>
<tr class="separator:ga3896cfd00446f4c179f8d4e9227248b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5c19b0cff457cc108bc2e9fb631504"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga9d5c19b0cff457cc108bc2e9fb631504"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga9d5c19b0cff457cc108bc2e9fb631504">eagine::memory::slice_before</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga9d5c19b0cff457cc108bc2e9fb631504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span before the first occurrence of <code>what</code>.  <a href="group__memory.html#ga9d5c19b0cff457cc108bc2e9fb631504">More...</a><br /></td></tr>
<tr class="separator:ga9d5c19b0cff457cc108bc2e9fb631504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8d84b1de5697a1fd4e75b5d583d7ed82"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga8d84b1de5697a1fd4e75b5d583d7ed82"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8d84b1de5697a1fd4e75b5d583d7ed82">eagine::memory::slice_after</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga8d84b1de5697a1fd4e75b5d583d7ed82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span after the first occurrence of <code>what</code>.  <a href="group__memory.html#ga8d84b1de5697a1fd4e75b5d583d7ed82">More...</a><br /></td></tr>
<tr class="separator:ga8d84b1de5697a1fd4e75b5d583d7ed82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef31ab0dbc5b78be9fa794e2ff03c804"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:gaef31ab0dbc5b78be9fa794e2ff03c804"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaef31ab0dbc5b78be9fa794e2ff03c804">eagine::memory::split_by_first</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; std::tuple&lt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&gt;</td></tr>
<tr class="memdesc:gaef31ab0dbc5b78be9fa794e2ff03c804"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a span by the first occurrence of <code>what</code> (before and after, what)  <a href="group__memory.html#gaef31ab0dbc5b78be9fa794e2ff03c804">More...</a><br /></td></tr>
<tr class="separator:gaef31ab0dbc5b78be9fa794e2ff03c804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99748da05d4557a4afd3a2605e0b1678"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga99748da05d4557a4afd3a2605e0b1678"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga99748da05d4557a4afd3a2605e0b1678">eagine::memory::slice_before_last</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga99748da05d4557a4afd3a2605e0b1678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span before the last occurrence of <code>what</code>.  <a href="group__memory.html#ga99748da05d4557a4afd3a2605e0b1678">More...</a><br /></td></tr>
<tr class="separator:ga99748da05d4557a4afd3a2605e0b1678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1c7708f142e25eebf500dc741d90f449"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga1c7708f142e25eebf500dc741d90f449"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1c7708f142e25eebf500dc741d90f449">eagine::memory::slice_after_last</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;</td></tr>
<tr class="memdesc:ga1c7708f142e25eebf500dc741d90f449"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span after the last occurrence of <code>what</code>.  <a href="group__memory.html#ga1c7708f142e25eebf500dc741d90f449">More...</a><br /></td></tr>
<tr class="separator:ga1c7708f142e25eebf500dc741d90f449"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e450a990335040aa66dd6bdc79afd42"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </td></tr>
<tr class="memitem:ga8e450a990335040aa66dd6bdc79afd42"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga8e450a990335040aa66dd6bdc79afd42">eagine::memory::split_by_last</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt; what) -&gt; std::tuple&lt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&gt;</td></tr>
<tr class="memdesc:ga8e450a990335040aa66dd6bdc79afd42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Splits a span by the last occurrence of <code>what</code> (before and after, what)  <a href="group__memory.html#ga8e450a990335040aa66dd6bdc79afd42">More...</a><br /></td></tr>
<tr class="separator:ga8e450a990335040aa66dd6bdc79afd42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0be018445182cd7c4f7040897d254d34"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename B &gt; </td></tr>
<tr class="memitem:ga0be018445182cd7c4f7040897d254d34"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">eagine::memory::slice_inside_brackets</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, B left, B right) noexcept -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga0be018445182cd7c4f7040897d254d34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a slice of span within a pair of brackets.  <a href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">More...</a><br /></td></tr>
<tr class="separator:ga0be018445182cd7c4f7040897d254d34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70a37717e232dc9da26a5647c8a351d3"><td class="memTemplParams" colspan="2">template&lt;typename TF , typename PF , typename SF , typename TT , typename PT , typename ST &gt; </td></tr>
<tr class="memitem:ga70a37717e232dc9da26a5647c8a351d3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga70a37717e232dc9da26a5647c8a351d3">eagine::memory::copy</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TF, PF, SF &gt; from, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt; to) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt;</td></tr>
<tr class="memdesc:ga70a37717e232dc9da26a5647c8a351d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the elements from one span to another compatible span.  <a href="group__memory.html#ga70a37717e232dc9da26a5647c8a351d3">More...</a><br /></td></tr>
<tr class="separator:ga70a37717e232dc9da26a5647c8a351d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab01ef0db74e313a46edd35fccbff02d0"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename V &gt; </td></tr>
<tr class="memitem:gab01ef0db74e313a46edd35fccbff02d0"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gab01ef0db74e313a46edd35fccbff02d0">eagine::memory::fill</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, const V &amp;v) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gab01ef0db74e313a46edd35fccbff02d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with copies of the specified value.  <a href="group__memory.html#gab01ef0db74e313a46edd35fccbff02d0">More...</a><br /></td></tr>
<tr class="separator:gab01ef0db74e313a46edd35fccbff02d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga04fe3ced764ad3fdf87bf32716910454"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga04fe3ced764ad3fdf87bf32716910454"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga04fe3ced764ad3fdf87bf32716910454">eagine::memory::zero</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; std::enable_if_t&lt; std::is_integral_v&lt; T &gt;||std::is_floating_point_v&lt; T &gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&gt;</td></tr>
<tr class="memdesc:ga04fe3ced764ad3fdf87bf32716910454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with zero value of type T.  <a href="group__memory.html#ga04fe3ced764ad3fdf87bf32716910454">More...</a><br /></td></tr>
<tr class="separator:ga04fe3ced764ad3fdf87bf32716910454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0fcc53ccd72374acc5d913064e01e8c9">eagine::memory::reverse</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverses the elements in a span.  <a href="group__memory.html#ga0fcc53ccd72374acc5d913064e01e8c9">More...</a><br /></td></tr>
<tr class="separator:ga0fcc53ccd72374acc5d913064e01e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0f7c39956697c400992558431e490ac"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:gab0f7c39956697c400992558431e490ac"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gab0f7c39956697c400992558431e490ac">eagine::memory::transform</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Transform function) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gab0f7c39956697c400992558431e490ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transforms the elements of a span with a <code>function</code>.  <a href="group__memory.html#gab0f7c39956697c400992558431e490ac">More...</a><br /></td></tr>
<tr class="separator:gab0f7c39956697c400992558431e490ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7a70ad3483da892c69fb46406573938"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Generator &gt; </td></tr>
<tr class="memitem:gae7a70ad3483da892c69fb46406573938"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gae7a70ad3483da892c69fb46406573938">eagine::memory::generate</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Generator gen) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gae7a70ad3483da892c69fb46406573938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills a span with elements generated by a generator callable.  <a href="group__memory.html#gae7a70ad3483da892c69fb46406573938">More...</a><br /></td></tr>
<tr class="separator:gae7a70ad3483da892c69fb46406573938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0139802989fce6bb9609b77eb447daa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename RandGen &gt; </td></tr>
<tr class="memitem:gaa0139802989fce6bb9609b77eb447daa"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gaa0139802989fce6bb9609b77eb447daa">eagine::memory::shuffle</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, RandGen rg) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gaa0139802989fce6bb9609b77eb447daa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shuffles the elements of a span.  <a href="group__memory.html#gaa0139802989fce6bb9609b77eb447daa">More...</a><br /></td></tr>
<tr class="separator:gaa0139802989fce6bb9609b77eb447daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad84cf3d7cf242c3f2d6f786668031276"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gad84cf3d7cf242c3f2d6f786668031276"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">eagine::memory::sort</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:gad84cf3d7cf242c3f2d6f786668031276"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a span.  <a href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">More...</a><br /></td></tr>
<tr class="separator:gad84cf3d7cf242c3f2d6f786668031276"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Compare &gt; </td></tr>
<tr class="memitem:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga36998dacf1d4c34b889c27d4e55fea2d">eagine::memory::sort</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Compare compare) -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;</td></tr>
<tr class="memdesc:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts the elements of a span according to <code>compare</code>.  <a href="group__memory.html#ga36998dacf1d4c34b889c27d4e55fea2d">More...</a><br /></td></tr>
<tr class="separator:ga36998dacf1d4c34b889c27d4e55fea2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ed9af20ab97eec8fb262a1f2c16e8c9"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI , typename Compare &gt; </td></tr>
<tr class="memitem:ga6ed9af20ab97eec8fb262a1f2c16e8c9"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6ed9af20ab97eec8fb262a1f2c16e8c9">eagine::memory::make_index</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt; idx, Compare compare) -&gt; bool</td></tr>
<tr class="memdesc:ga6ed9af20ab97eec8fb262a1f2c16e8c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the index of a span according to <code>compare</code>, into another span.  <a href="group__memory.html#ga6ed9af20ab97eec8fb262a1f2c16e8c9">More...</a><br /></td></tr>
<tr class="separator:ga6ed9af20ab97eec8fb262a1f2c16e8c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4880f16afaf75395abf7a756aaac3a32"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI &gt; </td></tr>
<tr class="memitem:ga4880f16afaf75395abf7a756aaac3a32"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga4880f16afaf75395abf7a756aaac3a32">eagine::memory::make_index</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt; idx) -&gt; bool</td></tr>
<tr class="memdesc:ga4880f16afaf75395abf7a756aaac3a32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes the index of a span, into another span.  <a href="group__memory.html#ga4880f16afaf75395abf7a756aaac3a32">More...</a><br /></td></tr>
<tr class="separator:ga4880f16afaf75395abf7a756aaac3a32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0702a862d4ce64f7889e51bef83bd5f3"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga0702a862d4ce64f7889e51bef83bd5f3"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga0702a862d4ce64f7889e51bef83bd5f3">eagine::memory::is_sorted</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn) -&gt; bool</td></tr>
<tr class="memdesc:ga0702a862d4ce64f7889e51bef83bd5f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the elements in a span are sorted.  <a href="group__memory.html#ga0702a862d4ce64f7889e51bef83bd5f3">More...</a><br /></td></tr>
<tr class="separator:ga0702a862d4ce64f7889e51bef83bd5f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga775e6a72cc81f280f00e068f4343ed6a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Compare &gt; </td></tr>
<tr class="memitem:ga775e6a72cc81f280f00e068f4343ed6a"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga775e6a72cc81f280f00e068f4343ed6a">eagine::memory::is_sorted</a> (<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt; spn, Compare compare) -&gt; bool</td></tr>
<tr class="memdesc:ga775e6a72cc81f280f00e068f4343ed6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if the elements in a span are sorted according to <code>compare</code>.  <a href="group__memory.html#ga775e6a72cc81f280f00e068f4343ed6a">More...</a><br /></td></tr>
<tr class="separator:ga775e6a72cc81f280f00e068f4343ed6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74307132ffa2433252a52cb23c47443e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Output &gt; </td></tr>
<tr class="memitem:ga74307132ffa2433252a52cb23c47443e"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga74307132ffa2433252a52cb23c47443e">list_to_stream</a> (Output &amp;out, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; Output &amp;</td></tr>
<tr class="memdesc:ga74307132ffa2433252a52cb23c47443e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for pretty-printing spans as lists into output streams.  <a href="group__memory.html#ga74307132ffa2433252a52cb23c47443e">More...</a><br /></td></tr>
<tr class="separator:ga74307132ffa2433252a52cb23c47443e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memTemplParams" colspan="2">template&lt;typename Input , typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">read_from_stream</a> (Input &amp;in, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; auto &amp;</td></tr>
<tr class="memdesc:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for raw-reading spans from output streams.  <a href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">More...</a><br /></td></tr>
<tr class="separator:ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6254cac01c4e968e5f66286a0f3d02b2"><td class="memTemplParams" colspan="2">template&lt;typename Output , typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga6254cac01c4e968e5f66286a0f3d02b2"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6254cac01c4e968e5f66286a0f3d02b2">write_to_stream</a> (Output &amp;out, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; auto &amp;</td></tr>
<tr class="memdesc:ga6254cac01c4e968e5f66286a0f3d02b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for raw-reading spans into output streams.  <a href="group__memory.html#ga6254cac01c4e968e5f66286a0f3d02b2">More...</a><br /></td></tr>
<tr class="separator:ga6254cac01c4e968e5f66286a0f3d02b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8e6de514ed1e9f2c45cb65b6c6874f5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:gad8e6de514ed1e9f2c45cb65b6c6874f5"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gad8e6de514ed1e9f2c45cb65b6c6874f5">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; s) -&gt; std::enable_if_t&lt;!std::is_same_v&lt; std::remove_const_t&lt; T &gt;, char &gt;, std::ostream &amp; &gt;</td></tr>
<tr class="memdesc:gad8e6de514ed1e9f2c45cb65b6c6874f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Operator for printing generic element spans into output streams.  <a href="group__memory.html#gad8e6de514ed1e9f2c45cb65b6c6874f5">More...</a><br /></td></tr>
<tr class="separator:gad8e6de514ed1e9f2c45cb65b6c6874f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27e8dfe09563b06924c6b747188db242"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga27e8dfe09563b06924c6b747188db242"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga27e8dfe09563b06924c6b747188db242">make_span_getter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn)</td></tr>
<tr class="memdesc:ga27e8dfe09563b06924c6b747188db242"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable that returns consecutive span elements starting at i.  <a href="group__memory.html#ga27e8dfe09563b06924c6b747188db242">More...</a><br /></td></tr>
<tr class="separator:ga27e8dfe09563b06924c6b747188db242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00e1233d172d43d1d49be6aa2974b2fe"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:ga00e1233d172d43d1d49be6aa2974b2fe"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga00e1233d172d43d1d49be6aa2974b2fe">make_span_getter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn, Transform transform)</td></tr>
<tr class="memdesc:ga00e1233d172d43d1d49be6aa2974b2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable getting consecutive, transformed span elements starting at i.  <a href="group__memory.html#ga00e1233d172d43d1d49be6aa2974b2fe">More...</a><br /></td></tr>
<tr class="separator:ga00e1233d172d43d1d49be6aa2974b2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S &gt; </td></tr>
<tr class="memitem:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd">make_span_putter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn)</td></tr>
<tr class="memdesc:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable setting consecutive elements of a span starting at i.  <a href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd">More...</a><br /></td></tr>
<tr class="separator:ga6e1777a757360856d19eb7ead9dc7cbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac618307bf991c77102ee6b4748c03419"><td class="memTemplParams" colspan="2">template&lt;typename T , typename P , typename S , typename Transform &gt; </td></tr>
<tr class="memitem:gac618307bf991c77102ee6b4748c03419"><td class="memTemplItemLeft" align="right" valign="top">static auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__memory.html#gac618307bf991c77102ee6b4748c03419">make_span_putter</a> (<a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;i, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt; spn, Transform transform)</td></tr>
<tr class="memdesc:gac618307bf991c77102ee6b4748c03419"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a callable setting consecutive elements of a span starting at i.  <a href="group__memory.html#gac618307bf991c77102ee6b4748c03419">More...</a><br /></td></tr>
<tr class="separator:gac618307bf991c77102ee6b4748c03419"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga5dd5ce1a14209336eb031bc930d736f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5dd5ce1a14209336eb031bc930d736f4">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">eagine::memory::block</a> = typedef <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for non-const byte memory span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2c_api_wrap_8cpp-example.html#a1">eagine/c_api_wrap.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga9abe6f67096b87cac1c3116a66379971"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9abe6f67096b87cac1c3116a66379971">&#9670;&nbsp;</a></span>const_block</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">eagine::memory::const_block</a> = typedef <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Alias for const byte memory span. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="application_2024_overdraw_2resources_8cpp-example.html#a13">application/024_overdraw/resources.cpp</a>, <a class="el" href="application_2025_recursive_cube_2resources_8cpp-example.html#a17">application/025_recursive_cube/resources.cpp</a>, <a class="el" href="application_2032_translucent_arrow_2resources_8cpp-example.html#a16">application/032_translucent_arrow/resources.cpp</a>, <a class="el" href="eagine_2c_api_wrap_8cpp-example.html#a2">eagine/c_api_wrap.cpp</a>, <a class="el" href="eagine_2compress_self_8cpp-example.html#a0">eagine/compress_self.cpp</a>, and <a class="el" href="eagine_2serialize_2003_packed_8cpp-example.html#a1">eagine/serialize/003_packed.cpp</a>.</dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga90527c44f086ae0f31578270c117d149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90527c44f086ae0f31578270c117d149">&#9670;&nbsp;</a></span>absolute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::absolute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, T*, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to span using a native pointer type. </p>
<dl class="section see"><dt>See also</dt><dd>relative </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1memory_1_1basic__span.html#gad8e6de514ed1e9f2c45cb65b6c6874f5">eagine::memory::basic_span&lt; const gl_types::ubyte_type &gt;::operator&lt;&lt;()</a>.</p>

</div>
</div>
<a id="ga90909590e59d12c65c69564051d53424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga90909590e59d12c65c69564051d53424">&#9670;&nbsp;</a></span>accomodate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename B , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::accomodate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; B, P, S &gt;&#160;</td>
          <td class="paramname"><em>blk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>tid</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;std::add_const_t&lt;T&gt;, rebind_pointer_t&lt;P, T&gt;, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a span, rebinding the element type (typically from basic_block). </p>
<dl class="section see"><dt>See also</dt><dd>as_bytes </dd>
<dd>
<a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1" title="Converts the embedded resource block to a const span of characters.">as_chars</a> </dd></dl>

</div>
</div>
<a id="gabb580346318713fe3ea7a3394adf1b0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabb580346318713fe3ea7a3394adf1b0b">&#9670;&nbsp;</a></span>align_down()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsConst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_down </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt;IsConst&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address down to the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gade92d5b382a2aa1e8b509c0af0f25c77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gade92d5b382a2aa1e8b509c0af0f25c77">&#9670;&nbsp;</a></span>align_down_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_down_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__type__utils.html#gaab46da9ac6255df6ca55cba220c61794">span_align_of</a>&lt;T&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em> = <code><a class="el" href="group__type__utils.html#gaedb51bc925f4e93cf94a96b25dce1bf4">span_size_of</a>&lt;T&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address down to the required alignment of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa85bb51167cba2b89aa607f12570e53e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa85bb51167cba2b89aa607f12570e53e">&#9670;&nbsp;</a></span>align_up()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool IsConst&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_up </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; IsConst &gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt;IsConst&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address up to the specified alignment. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8858b4badb595974db9980837d2d250f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8858b4badb595974db9980837d2d250f">&#9670;&nbsp;</a></span>align_up_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::align_up_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__address.html">basic_address</a>&lt; std::is_const_v&lt; T &gt;&gt;&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structeagine_1_1type__identity.html">type_identity</a>&lt; T &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>align</em> = <code><a class="el" href="group__type__utils.html#gaab46da9ac6255df6ca55cba220c61794">span_align_of</a>&lt;T&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a>&#160;</td>
          <td class="paramname"><em>max</em> = <code><a class="el" href="group__type__utils.html#gaedb51bc925f4e93cf94a96b25dce1bf4">span_size_of</a>&lt;T&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Aligns a memory address up to the required alignment of type T. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max</td><td>The maximum byte offset that can be applied to the address. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74ce9ca5ad1a664db09d395022179f3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74ce9ca5ad1a664db09d395022179f3b">&#9670;&nbsp;</a></span>as_bytes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="group__type__utils.html#ga8da7f49dadf801add5106aeaaf050f7b">basic_block</a>&lt;std::is_const_v&lt;T&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a span into a basic_block. </p>
<dl class="section see"><dt>See also</dt><dd>accomodate </dd>
<dd>
<a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1" title="Converts the embedded resource block to a const span of characters.">as_chars</a> </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="application_2010_newton_2main_8cpp-example.html#a11">application/010_newton/main.cpp</a>, <a class="el" href="application_2011_mandelbrot_2main_8cpp-example.html#a11">application/011_mandelbrot/main.cpp</a>, <a class="el" href="application_2014_voronoi_2resources_8cpp-example.html#a1">application/014_voronoi/resources.cpp</a>, <a class="el" href="application_2015_worley_2resources_8cpp-example.html#a1">application/015_worley/resources.cpp</a>, <a class="el" href="application_2023_sketch_2resources_8cpp-example.html#a16">application/023_sketch/resources.cpp</a>, <a class="el" href="eagine_2message_bus_2001_loopback_8cpp-example.html#a5">eagine/message_bus/001_loopback.cpp</a>, <a class="el" href="eagine_2message_bus_2002_direct_8cpp-example.html#a5">eagine/message_bus/002_direct.cpp</a>, and <a class="el" href="eagine_2serialize_2002_string_8cpp-example.html#a3">eagine/serialize/002_string.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1basic__string__path.html#a5dd30bbded70679b8bcfd158942417e8">eagine::basic_string_path::block()</a>, <a class="el" href="classeagine_1_1program__arg.html#a9af6d8ef0e07262587bfff1ab38191e8">eagine::program_arg::block()</a>, <a class="el" href="classeagine_1_1memory_1_1aligned__block.html#aebd5d1a770dc32745e32739673160aa4">eagine::memory::aligned_block&lt; 63 *1024 &gt;::get()</a>, <a class="el" href="structeagine_1_1msgbus_1_1message__view.html#a7ec579c0d0e302257789cf701c04e215">eagine::msgbus::message_view::message_view()</a>, and <a class="el" href="structeagine_1_1serializer__data__sink.html#aad6439c7909084712a53208a61b3866b">eagine::serializer_data_sink::write()</a>.</p>

</div>
</div>
<a id="ga09b22ac988a3d779f428c3e461cc2ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga09b22ac988a3d779f428c3e461cc2ccf">&#9670;&nbsp;</a></span>as_chars() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a>&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a block into a span of characters. </p>
<dl class="section see"><dt>See also</dt><dd>accomodate </dd>
<dd>
as_bytes </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="application_2000_stencil_shadow_2main_8cpp-example.html#a10">application/000_stencil_shadow/main.cpp</a>, <a class="el" href="application_2008_yaml_shape_2main_8cpp-example.html#a6">application/008_yaml_shape/main.cpp</a>, <a class="el" href="application_2009_json_shape_2main_8cpp-example.html#a6">application/009_json_shape/main.cpp</a>, <a class="el" href="application_2017_occlusion_2main_8cpp-example.html#a7">application/017_occlusion/main.cpp</a>, <a class="el" href="application_2018_uv_map_2main_8cpp-example.html#a7">application/018_uv_map/main.cpp</a>, <a class="el" href="application_2026_halo_2main_8cpp-example.html#a10">application/026_halo/main.cpp</a>, <a class="el" href="application_2032_translucent_arrow_2resources_8cpp-example.html#a8">application/032_translucent_arrow/resources.cpp</a>, and <a class="el" href="eagine_2ecs_2elements_2init_8cpp-example.html#a7">eagine/ecs/elements/init.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__embedding.html#gaa4d95a4c9285f038fa9e81662d2bf7e1">eagine::embedded_resource::as_chars()</a>, and <a class="el" href="classeagine_1_1msgbus_1_1stored__message.html#a0e6808c99cb3b91535822c4773782adb">eagine::msgbus::stored_message::text_content()</a>.</p>

</div>
</div>
<a id="ga75034d39aa1ee61d725905a3b3d33a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga75034d39aa1ee61d725905a3b3d33a90">&#9670;&nbsp;</a></span>as_chars() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::as_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>blk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a block into a span of characters. </p>
<dl class="section see"><dt>See also</dt><dd>accomodate </dd>
<dd>
as_bytes </dd></dl>

</div>
</div>
<a id="ga118ce06e388d17bfb743ed21a4ab62f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga118ce06e388d17bfb743ed21a4ab62f8">&#9670;&nbsp;</a></span>contains()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; S1 </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if a span contains the contents of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
ends_with </dd></dl>

</div>
</div>
<a id="ga70a37717e232dc9da26a5647c8a351d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70a37717e232dc9da26a5647c8a351d3">&#9670;&nbsp;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TF , typename PF , typename SF , typename TT , typename PT , typename ST &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TF, PF, SF &gt;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; TT, PT, ST &gt;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;TT, PT, ST&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the elements from one span to another compatible span. </p>
<dl class="section see"><dt>See also</dt><dd>fill </dd>
<dd>
zero </dd>
<dd>
generate </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga70a37717e232dc9da26a5647c8a351d3">eagine::memory::copy()</a>.</p>

</div>
</div>
<a id="ga4a9fddc58451ef62a96bc9d3fadfb011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4a9fddc58451ef62a96bc9d3fadfb011">&#9670;&nbsp;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of source block to destination block. </p>
<dl class="section see"><dt>See also</dt><dd>const_block </dd>
<dd>
block </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga4a9fddc58451ef62a96bc9d3fadfb011">eagine::memory::copy()</a>, <a class="el" href="group__memory.html#ga975d696b679b6918b61e8333c82bfeda">eagine::memory::copy_into()</a>, and <a class="el" href="classeagine_1_1istream__data__source.html#a159587f23be8eb41eb49ad4f602d2231">eagine::istream_data_source::pop()</a>.</p>

</div>
</div>
<a id="ga975d696b679b6918b61e8333c82bfeda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga975d696b679b6918b61e8333c82bfeda">&#9670;&nbsp;</a></span>copy_into()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::copy_into </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__memory.html#ga9abe6f67096b87cac1c3116a66379971">const_block</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1buffer.html">buffer</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__memory.html#ga5dd5ce1a14209336eb031bc930d736f4">block</a> </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the content of source block to destination buffer. </p>
<dl class="section see"><dt>See also</dt><dd>const_block </dd>
<dd>
<a class="el" href="classeagine_1_1memory_1_1buffer.html" title="Reallocatable owning byte buffer.">buffer</a> </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1msgbus_1_1stored__message.html#aab5e88320b23b095d25e6655498426f4">eagine::msgbus::stored_message::store_content()</a>, and <a class="el" href="classeagine_1_1embedded__resource.html#adfbab3d4e3ebfd0d967572da6362d473">eagine::embedded_resource::unpack()</a>.</p>

</div>
</div>
<a id="gac32ab0924bf65443c2264c4b882cf474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32ab0924bf65443c2264c4b882cf474">&#9670;&nbsp;</a></span>ends_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::ends_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if span <code>spn</code> ends with the content of <code>with</code>. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
contains </dd>
<dd>
strip_suffix </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1program__arg.html#a5532e31bd5ed270d0de09cb47bd79dc1">eagine::program_arg::ends_with()</a>, and <a class="el" href="group__memory.html#ga6a7857c935a23ecdf6544cf7e565098f">eagine::memory::strip_suffix()</a>.</p>

</div>
</div>
<a id="ga05e741e072a75182869ff2c0cfbb83be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga05e741e072a75182869ff2c0cfbb83be">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::extract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; T&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Overload of extract for spans. Returns the first element,. </p>
<dl class="section pre"><dt>Precondition</dt><dd>spn.size() &gt;= 1 </dd></dl>

</div>
</div>
<a id="gab01ef0db74e313a46edd35fccbff02d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab01ef0db74e313a46edd35fccbff02d0">&#9670;&nbsp;</a></span>fill()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with copies of the specified value. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
zero </dd>
<dd>
generate </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="application_2028_compute_particles_2resources_8cpp-example.html#a3">application/028_compute_particles/resources.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga04fe3ced764ad3fdf87bf32716910454">eagine::memory::zero()</a>.</p>

</div>
</div>
<a id="ga3896cfd00446f4c179f8d4e9227248b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3896cfd00446f4c179f8d4e9227248b9">&#9670;&nbsp;</a></span>find()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>where</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the last occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find_element </dd>
<dd>
find_element_if </dd>
<dd>
find_position </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2dyn_lib_lookup_8cpp-example.html#a1">eagine/dyn_lib_lookup.cpp</a>, <a class="el" href="eagine_2message_bus_2006_ping_8cpp-example.html#a10">eagine/message_bus/006_ping.cpp</a>, <a class="el" href="eagine_2message_bus_2007_ping_8cpp-example.html#a13">eagine/message_bus/007_ping.cpp</a>, <a class="el" href="eagine_2message_bus_2007_pong_8cpp-example.html#a6">eagine/message_bus/007_pong.cpp</a>, and <a class="el" href="eagine_2message_bus_2008_pong_registry_8cpp-example.html#a5">eagine/message_bus/008_pong_registry.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga7c8aa8f76aa003ce6a549f25025641dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7c8aa8f76aa003ce6a549f25025641dc">&#9670;&nbsp;</a></span>find_element()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename E &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_element </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">E&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_position </dd>
<dd>
find_element_if </dd>
<dd>
reverse_find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">eagine::memory::slice_inside_brackets()</a>.</p>

</div>
</div>
<a id="ga736704005e11e09e06cef0faa10c1518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga736704005e11e09e06cef0faa10c1518">&#9670;&nbsp;</a></span>find_element_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename F &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_element_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">F&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first element satisfying <code>predicate</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_position </dd>
<dd>
find_element </dd>
<dd>
reverse_find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga6f0570550eacf320c8a6c79504106966">eagine::memory::skip_until()</a>, and <a class="el" href="group__memory.html#gad662b6d4685ae624c3da06ba0dd7d48b">eagine::memory::take_until()</a>.</p>

</div>
</div>
<a id="ga3cb0bbcf75b8f7a1c90e5006aac386bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb0bbcf75b8f7a1c90e5006aac386bb">&#9670;&nbsp;</a></span>find_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::find_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the first occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find </dd>
<dd>
find_element </dd>
<dd>
find_element_if </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga3896cfd00446f4c179f8d4e9227248b9">eagine::memory::find()</a>, <a class="el" href="group__type__utils.html#ga286bbf2c9da85f3783a1c647a5307dd6">eagine::memory::for_each_delimited()</a>, <a class="el" href="group__memory.html#ga8d84b1de5697a1fd4e75b5d583d7ed82">eagine::memory::slice_after()</a>, <a class="el" href="group__memory.html#ga9d5c19b0cff457cc108bc2e9fb631504">eagine::memory::slice_before()</a>, and <a class="el" href="group__memory.html#gaef31ab0dbc5b78be9fa794e2ff03c804">eagine::memory::split_by_first()</a>.</p>

</div>
</div>
<a id="gae7a70ad3483da892c69fb46406573938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7a70ad3483da892c69fb46406573938">&#9670;&nbsp;</a></span>generate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Generator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::generate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Generator&#160;</td>
          <td class="paramname"><em>gen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with elements generated by a generator callable. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
fill </dd>
<dd>
zero </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2make_index_8cpp-example.html#a0">eagine/make_index.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1application_1_1context__state.html#a3dcdb4ffa87bef6641505dc6d37ba397">eagine::application::context_state::random_normal()</a>, <a class="el" href="classeagine_1_1application_1_1context__state.html#a3dc875e42e7a9e8a68d6ecf87049be13">eagine::application::context_state::random_uniform()</a>, and <a class="el" href="classeagine_1_1application_1_1context__state.html#a3c3ade7493de8e5fce9a4a267ff7ba33">eagine::application::context_state::random_uniform_01()</a>.</p>

</div>
</div>
<a id="gac32f48e6dee85c700216be2c57834de9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac32f48e6dee85c700216be2c57834de9">&#9670;&nbsp;</a></span>head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the first <code>l</code> elements from the front of a span. </p>
<dl class="section see"><dt>See also</dt><dd>tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1block__data__sink.html#aa83c1a3382952caa03e7d4c4a76ead23">eagine::block_data_sink::done()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#adc4fd3567337539120801cf0620effce">eagine::valtree::compound::fetch_values()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a159587f23be8eb41eb49ad4f602d2231">eagine::istream_data_source::pop()</a>, <a class="el" href="classeagine_1_1msgbus_1_1posix__mqueue.html#ae99a4f9e719c91726e91aee2ba20c643">eagine::msgbus::posix_mqueue::receive()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#ab2972d62312d1512712a37abd6d32784">eagine::valtree::compound::select_values()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#aad0d85778b3cdcb946103de532ea8b65">eagine::istream_data_source::top()</a>, <a class="el" href="classeagine_1_1block__data__source.html#a97f002570f1793b084aed9741a803788">eagine::block_data_source::top()</a>, and <a class="el" href="classeagine_1_1block__data__sink.html#a2b2a94897f8cdb148082a77dc7e428ef">eagine::block_data_sink::write()</a>.</p>

</div>
</div>
<a id="ga685dcc8870589231d3f43f2b4553230e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga685dcc8870589231d3f43f2b4553230e">&#9670;&nbsp;</a></span>head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;Ts, Ps, Ss&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the head of <code>s</code> l.size() elements long. </p>
<dl class="section see"><dt>See also</dt><dd>tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__type__utils.html#ga286bbf2c9da85f3783a1c647a5307dd6">eagine::memory::for_each_delimited()</a>, <a class="el" href="group__memory.html#ga9d5c19b0cff457cc108bc2e9fb631504">eagine::memory::slice_before()</a>, <a class="el" href="group__memory.html#ga99748da05d4557a4afd3a2605e0b1678">eagine::memory::slice_before_last()</a>, <a class="el" href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">eagine::memory::slice_inside_brackets()</a>, <a class="el" href="group__memory.html#gaaccf80c25c79b01fe71ec07170cee083">eagine::memory::snip()</a>, <a class="el" href="group__memory.html#gaef31ab0dbc5b78be9fa794e2ff03c804">eagine::memory::split_by_first()</a>, <a class="el" href="group__memory.html#ga8e450a990335040aa66dd6bdc79afd42">eagine::memory::split_by_last()</a>, <a class="el" href="group__memory.html#ga5b6c48e81631ada4a7d63cf0186814a3">eagine::memory::starts_with()</a>, and <a class="el" href="group__memory.html#gad662b6d4685ae624c3da06ba0dd7d48b">eagine::memory::take_until()</a>.</p>

</div>
</div>
<a id="ga0702a862d4ce64f7889e51bef83bd5f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0702a862d4ce64f7889e51bef83bd5f3">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the elements in a span are sorted. </p>
<dl class="section see"><dt>See also</dt><dd>sort </dd>
<dd>
shuffle </dd>
<dd>
make_index </dd></dl>

</div>
</div>
<a id="ga775e6a72cc81f280f00e068f4343ed6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga775e6a72cc81f280f00e068f4343ed6a">&#9670;&nbsp;</a></span>is_sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::is_sorted </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests if the elements in a span are sorted according to <code>compare</code>. </p>
<dl class="section see"><dt>See also</dt><dd>sort </dd>
<dd>
shuffle </dd>
<dd>
make_index </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga0702a862d4ce64f7889e51bef83bd5f3">eagine::memory::is_sorted()</a>.</p>

</div>
</div>
<a id="ga74307132ffa2433252a52cb23c47443e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74307132ffa2433252a52cb23c47443e">&#9670;&nbsp;</a></span>list_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Output &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto list_to_stream </td>
          <td>(</td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; Output&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for pretty-printing spans as lists into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6254cac01c4e968e5f66286a0f3d02b2" title="Helper function for raw-reading spans into output streams.">write_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga4880f16afaf75395abf7a756aaac3a32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4880f16afaf75395abf7a756aaac3a32">&#9670;&nbsp;</a></span>make_index() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::make_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt;&#160;</td>
          <td class="paramname"><em>idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the index of a span, into another span. </p>
<dl class="section see"><dt>See also</dt><dd>is_sorted </dd>
<dd>
sort </dd>
<dd>
shuffle </dd></dl>

</div>
</div>
<a id="ga6ed9af20ab97eec8fb262a1f2c16e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ed9af20ab97eec8fb262a1f2c16e8c9">&#9670;&nbsp;</a></span>make_index() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename PI , typename SI , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::make_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; I, PI, SI &gt;&#160;</td>
          <td class="paramname"><em>idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes the index of a span according to <code>compare</code>, into another span. </p>
<dl class="section see"><dt>See also</dt><dd>is_sorted </dd>
<dd>
sort </dd>
<dd>
shuffle </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2make_index_8cpp-example.html#a2">eagine/make_index.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga27e8dfe09563b06924c6b747188db242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga27e8dfe09563b06924c6b747188db242">&#9670;&nbsp;</a></span>make_span_getter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable that returns consecutive span elements starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd" title="Makes a callable setting consecutive elements of a span starting at i.">make_span_putter</a></dd></dl>
<p>The constructed callable object does not take any arguments in the call operator and returns optional values of T. </p>

</div>
</div>
<a id="ga00e1233d172d43d1d49be6aa2974b2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00e1233d172d43d1d49be6aa2974b2fe">&#9670;&nbsp;</a></span>make_span_getter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_getter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable getting consecutive, transformed span elements starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6e1777a757360856d19eb7ead9dc7cbd" title="Makes a callable setting consecutive elements of a span starting at i.">make_span_putter</a></dd></dl>
<p>The constructed callable object does not take any arguments in the call operator and returns the result of the transform function. The transform function takes a single optional value of T. </p>

</div>
</div>
<a id="ga6e1777a757360856d19eb7ead9dc7cbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e1777a757360856d19eb7ead9dc7cbd">&#9670;&nbsp;</a></span>make_span_putter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_putter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable setting consecutive elements of a span starting at i. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga27e8dfe09563b06924c6b747188db242" title="Makes a callable that returns consecutive span elements starting at i.">make_span_getter</a></dd></dl>
<p>The constructed callable takes a single value explicitly convertible to T. </p>

</div>
</div>
<a id="gac618307bf991c77102ee6b4748c03419"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac618307bf991c77102ee6b4748c03419">&#9670;&nbsp;</a></span>make_span_putter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto make_span_putter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__type__utils.html#ga45c24c96dddc1fd15429ed38f016d1ef">span_size_t</a> &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>transform</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Makes a callable setting consecutive elements of a span starting at i. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>transformation operation to be applied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga27e8dfe09563b06924c6b747188db242" title="Makes a callable that returns consecutive span elements starting at i.">make_span_getter</a></dd></dl>
<p>The constructed callable takes a single value explicitly convertible to the argument of the transform function. </p>

</div>
</div>
<a id="gad8e6de514ed1e9f2c45cb65b6c6874f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8e6de514ed1e9f2c45cb65b6c6874f5">&#9670;&nbsp;</a></span>operator&lt;&lt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::
    enable_if_t&lt;!std::is_same_v&lt;std::remove_const_t&lt;T&gt;, char&gt;, std::ostream&amp;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Operator for printing generic element spans into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga74307132ffa2433252a52cb23c47443e" title="Helper function for pretty-printing spans as lists into output streams.">list_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga1b0b92acd6ef6c1e9bb9f1a1d932d29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b">&#9670;&nbsp;</a></span>read_from_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Input , typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto read_from_stream </td>
          <td>(</td>
          <td class="paramtype">Input &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; auto&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for raw-reading spans from output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga6254cac01c4e968e5f66286a0f3d02b2" title="Helper function for raw-reading spans into output streams.">write_to_stream</a> </dd></dl>

</div>
</div>
<a id="gadd2bd8629c6e69e1b9ee40ad72e61876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadd2bd8629c6e69e1b9ee40ad72e61876">&#9670;&nbsp;</a></span>relative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::relative </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, <a class="el" href="classeagine_1_1memory_1_1basic__offset__ptr.html">basic_offset_ptr</a>&lt;T, std::make_signed_t&lt;S&gt;&gt;, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts argument to span using an offset pointer type. </p>
<dl class="section see"><dt>See also</dt><dd>absolute </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gadd2bd8629c6e69e1b9ee40ad72e61876">eagine::memory::relative()</a>.</p>

</div>
</div>
<a id="ga0fcc53ccd72374acc5d913064e01e8c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fcc53ccd72374acc5d913064e01e8c9">&#9670;&nbsp;</a></span>reverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::reverse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverses the elements in a span. </p>
<dl class="section see"><dt>See also</dt><dd>transform </dd>
<dd>
shuffle </dd>
<dd>
sort </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2message_bus_2001_loopback_8cpp-example.html#a3">eagine/message_bus/001_loopback.cpp</a>, and <a class="el" href="eagine_2message_bus_2002_direct_8cpp-example.html#a3">eagine/message_bus/002_direct.cpp</a>.</dd>
</dl>

</div>
</div>
<a id="ga3db554dceef2dcb97e9a95ecdf96d837"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3db554dceef2dcb97e9a95ecdf96d837">&#9670;&nbsp;</a></span>reverse_find_position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::reverse_find_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="group__valid__if.html#ga22f90263d27c63b9dd286602484b9037">optionally_valid</a>&lt;S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Finds the position of the last occurrence of <code>what</code> in a span. </p>
<dl class="section see"><dt>See also</dt><dd>find_position </dd>
<dd>
find_position_if </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga1c7708f142e25eebf500dc741d90f449">eagine::memory::slice_after_last()</a>, <a class="el" href="group__memory.html#ga99748da05d4557a4afd3a2605e0b1678">eagine::memory::slice_before_last()</a>, and <a class="el" href="group__memory.html#ga8e450a990335040aa66dd6bdc79afd42">eagine::memory::split_by_last()</a>.</p>

</div>
</div>
<a id="ga001c145b85d45759647de6a1013c35b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga001c145b85d45759647de6a1013c35b7">&#9670;&nbsp;</a></span>shrink()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::shrink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shrinks a span by removing a specified count of elements from both sides. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">eagine::memory::slice_inside_brackets()</a>.</p>

</div>
</div>
<a id="gaa0139802989fce6bb9609b77eb447daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa0139802989fce6bb9609b77eb447daa">&#9670;&nbsp;</a></span>shuffle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename RandGen &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::shuffle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandGen&#160;</td>
          <td class="paramname"><em>rg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Shuffles the elements of a span. </p>
<dl class="section see"><dt>See also</dt><dd>reverse </dd>
<dd>
sort </dd>
<dd>
is_sorted </dd></dl>

</div>
</div>
<a id="ga043f365df2ad028630a9db3b699e9a9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga043f365df2ad028630a9db3b699e9a9c">&#9670;&nbsp;</a></span>skip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips a specified count of elements from the front of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga118ce06e388d17bfb743ed21a4ab62f8">eagine::memory::contains()</a>, <a class="el" href="group__memory.html#ga3896cfd00446f4c179f8d4e9227248b9">eagine::memory::find()</a>, <a class="el" href="group__memory.html#ga3cb0bbcf75b8f7a1c90e5006aac386bb">eagine::memory::find_position()</a>, <a class="el" href="group__type__utils.html#ga286bbf2c9da85f3783a1c647a5307dd6">eagine::memory::for_each_delimited()</a>, <a class="el" href="classeagine_1_1block__data__sink.html#ae2e2441d94fc755efd26163c99212498">eagine::block_data_sink::free()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#a159587f23be8eb41eb49ad4f602d2231">eagine::istream_data_source::pop()</a>, <a class="el" href="group__memory.html#ga3db554dceef2dcb97e9a95ecdf96d837">eagine::memory::reverse_find_position()</a>, <a class="el" href="group__memory.html#ga001c145b85d45759647de6a1013c35b7">eagine::memory::shrink()</a>, <a class="el" href="classeagine_1_1msgbus_1_1stored__message.html#ac9aa4b333ab639494cf4e2849cea26fd">eagine::msgbus::stored_message::signature()</a>, <a class="el" href="group__memory.html#ga6f0570550eacf320c8a6c79504106966">eagine::memory::skip_until()</a>, <a class="el" href="group__memory.html#ga8d84b1de5697a1fd4e75b5d583d7ed82">eagine::memory::slice_after()</a>, <a class="el" href="group__memory.html#ga1c7708f142e25eebf500dc741d90f449">eagine::memory::slice_after_last()</a>, <a class="el" href="group__memory.html#ga0be018445182cd7c4f7040897d254d34">eagine::memory::slice_inside_brackets()</a>, <a class="el" href="group__memory.html#gaef31ab0dbc5b78be9fa794e2ff03c804">eagine::memory::split_by_first()</a>, <a class="el" href="group__memory.html#ga8e450a990335040aa66dd6bdc79afd42">eagine::memory::split_by_last()</a>, <a class="el" href="group__memory.html#gab18d064b092370605f7fad13b9b1bf73">eagine::memory::strip_prefix()</a>, <a class="el" href="classeagine_1_1memory_1_1basic__split__span.html#a4ef4a6233167955d6d9476d3947d371a">eagine::memory::basic_split_span&lt; ValueType, Pointer, SizeType &gt;::tail()</a>, <a class="el" href="group__memory.html#ga10e323de0d244d2aa0760ce092d16478">eagine::memory::tail()</a>, <a class="el" href="classeagine_1_1istream__data__source.html#aad0d85778b3cdcb946103de532ea8b65">eagine::istream_data_source::top()</a>, and <a class="el" href="classeagine_1_1block__data__source.html#a97f002570f1793b084aed9741a803788">eagine::block_data_source::top()</a>.</p>

</div>
</div>
<a id="ga6f0570550eacf320c8a6c79504106966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6f0570550eacf320c8a6c79504106966">&#9670;&nbsp;</a></span>skip_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::skip_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Skips the elements from the front of a span until <code>predicate</code> is satisfied. </p>
<dl class="section see"><dt>See also</dt><dd>take_until </dd></dl>

</div>
</div>
<a id="gacf535a58f631ee947e5835f5a4dc5e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacf535a58f631ee947e5835f5a4dc5e19">&#9670;&nbsp;</a></span>slice()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename I , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">I&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span starting at specified index with specified length. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
skip </dd>
<dd>
snip </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__type__utils.html#gaae35e9ec5c2a721f696b50d75990ea8a">eagine::memory::for_each_chunk()</a>, <a class="el" href="group__memory.html#gac32f48e6dee85c700216be2c57834de9">eagine::memory::head()</a>, and <a class="el" href="group__memory.html#ga043f365df2ad028630a9db3b699e9a9c">eagine::memory::skip()</a>.</p>

</div>
</div>
<a id="ga8d84b1de5697a1fd4e75b5d583d7ed82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8d84b1de5697a1fd4e75b5d583d7ed82">&#9670;&nbsp;</a></span>slice_after()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_after </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span after the first occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>slice_before </dd>
<dd>
find_position </dd></dl>

</div>
</div>
<a id="ga1c7708f142e25eebf500dc741d90f449"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1c7708f142e25eebf500dc741d90f449">&#9670;&nbsp;</a></span>slice_after_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_after_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span after the last occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

</div>
</div>
<a id="ga9d5c19b0cff457cc108bc2e9fb631504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9d5c19b0cff457cc108bc2e9fb631504">&#9670;&nbsp;</a></span>slice_before()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_before </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span before the first occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>slice_after </dd>
<dd>
find_position </dd></dl>

</div>
</div>
<a id="ga99748da05d4557a4afd3a2605e0b1678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga99748da05d4557a4afd3a2605e0b1678">&#9670;&nbsp;</a></span>slice_before_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_before_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span before the last occurrence of <code>what</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

</div>
</div>
<a id="ga0be018445182cd7c4f7040897d254d34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0be018445182cd7c4f7040897d254d34">&#9670;&nbsp;</a></span>slice_inside_brackets()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename B &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::slice_inside_brackets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">B&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a slice of span within a pair of brackets. </p>
<dl class="section see"><dt>See also</dt><dd>find_element </dd></dl>

</div>
</div>
<a id="gaaccf80c25c79b01fe71ec07170cee083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaccf80c25c79b01fe71ec07170cee083">&#9670;&nbsp;</a></span>snip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::snip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Snips a specified count of elements from the back of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
tail </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga001c145b85d45759647de6a1013c35b7">eagine::memory::shrink()</a>, and <a class="el" href="group__memory.html#ga6a7857c935a23ecdf6544cf7e565098f">eagine::memory::strip_suffix()</a>.</p>

</div>
</div>
<a id="gad84cf3d7cf242c3f2d6f786668031276"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad84cf3d7cf242c3f2d6f786668031276">&#9670;&nbsp;</a></span>sort() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a span. </p>
<dl class="section see"><dt>See also</dt><dd>reverse </dd>
<dd>
shuffle </dd>
<dd>
is_sorted </dd>
<dd>
make_index </dd></dl>

</div>
</div>
<a id="ga36998dacf1d4c34b889c27d4e55fea2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36998dacf1d4c34b889c27d4e55fea2d">&#9670;&nbsp;</a></span>sort() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>compare</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts the elements of a span according to <code>compare</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse </dd>
<dd>
shuffle </dd>
<dd>
is_sorted </dd>
<dd>
make_index </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga6ed9af20ab97eec8fb262a1f2c16e8c9">eagine::memory::make_index()</a>, and <a class="el" href="group__memory.html#gad84cf3d7cf242c3f2d6f786668031276">eagine::memory::sort()</a>.</p>

</div>
</div>
<a id="gaef31ab0dbc5b78be9fa794e2ff03c804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaef31ab0dbc5b78be9fa794e2ff03c804">&#9670;&nbsp;</a></span>split_by_first()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::split_by_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a span by the first occurrence of <code>what</code> (before and after, what) </p>
<dl class="section see"><dt>See also</dt><dd>find_position </dd></dl>

</div>
</div>
<a id="ga8e450a990335040aa66dd6bdc79afd42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8e450a990335040aa66dd6bdc79afd42">&#9670;&nbsp;</a></span>split_by_last()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::split_by_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>what</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; std::tuple&lt;<a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;, <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Splits a span by the last occurrence of <code>what</code> (before and after, what) </p>
<dl class="section see"><dt>See also</dt><dd>reverse_find_position </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__msgbus.html#ga8c1e636ec64d7bcdf8a166dc64f29a4b">eagine::msgbus::parse_ipv4_addr()</a>.</p>

</div>
</div>
<a id="ga5b6c48e81631ada4a7d63cf0186814a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b6c48e81631ada4a7d63cf0186814a3">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::starts_with </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>with</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; bool </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Indicates if span <code>spn</code> starts with the content of <code>with</code>. </p>
<dl class="section see"><dt>See also</dt><dd>ends_with </dd>
<dd>
contains </dd>
<dd>
strip_prefix </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#ga118ce06e388d17bfb743ed21a4ab62f8">eagine::memory::contains()</a>, <a class="el" href="group__memory.html#ga3cb0bbcf75b8f7a1c90e5006aac386bb">eagine::memory::find_position()</a>, <a class="el" href="classeagine_1_1valtree_1_1compound.html#a1a6812b3774f32b6cab8f53fb4c3eb5b">eagine::valtree::compound::has_value()</a>, <a class="el" href="group__memory.html#ga3db554dceef2dcb97e9a95ecdf96d837">eagine::memory::reverse_find_position()</a>, <a class="el" href="classeagine_1_1program__arg.html#a4f099978a15d5b1f9551b84efba825b7">eagine::program_arg::starts_with()</a>, and <a class="el" href="group__memory.html#gab18d064b092370605f7fad13b9b1bf73">eagine::memory::strip_prefix()</a>.</p>

</div>
</div>
<a id="gab18d064b092370605f7fad13b9b1bf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab18d064b092370605f7fad13b9b1bf73">&#9670;&nbsp;</a></span>strip_prefix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::strip_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the specified <code>prefix</code> from a span. </p>
<dl class="section see"><dt>See also</dt><dd>starts_with </dd>
<dd>
strip_suffix </dd></dl>

</div>
</div>
<a id="ga6a7857c935a23ecdf6544cf7e565098f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7857c935a23ecdf6544cf7e565098f">&#9670;&nbsp;</a></span>strip_suffix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename P1 , typename S1 , typename T2 , typename P2 , typename S2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::strip_suffix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T1, P1, S1 &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T2, P2, S2 &gt;&#160;</td>
          <td class="paramname"><em>suffix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T1, P1, S1&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strips the specified <code>suffix</code> from a span. </p>
<dl class="section see"><dt>See also</dt><dd>ends_with </dd>
<dd>
strip_prefix </dd></dl>

</div>
</div>
<a id="ga10e323de0d244d2aa0760ce092d16478"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10e323de0d244d2aa0760ce092d16478">&#9670;&nbsp;</a></span>tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename L &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">L&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the last <code>l</code> elements from the back of a span. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

</div>
</div>
<a id="ga7802c35f2ff0bc4988d707ea0fdf4e56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7802c35f2ff0bc4988d707ea0fdf4e56">&#9670;&nbsp;</a></span>tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Ts , typename Ps , typename Ss , typename Tl , typename Pl , typename Sl &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Ts, Ps, Ss &gt;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; Tl, Pl, Sl &gt;&#160;</td>
          <td class="paramname"><em>l</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;Ts, Ps, Ss&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the tail of <code>s</code> l.size() elements long. </p>
<dl class="section see"><dt>See also</dt><dd>head </dd>
<dd>
slice </dd>
<dd>
skip </dd>
<dd>
snip </dd>
<dd>
shrink </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gac32ab0924bf65443c2264c4b882cf474">eagine::memory::ends_with()</a>.</p>

</div>
</div>
<a id="gad662b6d4685ae624c3da06ba0dd7d48b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad662b6d4685ae624c3da06ba0dd7d48b">&#9670;&nbsp;</a></span>take_until()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr auto eagine::memory::take_until </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>predicate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes the elements from the front of a span until <code>predicate</code> is satisfied. </p>
<dl class="section see"><dt>See also</dt><dd>skip_until </dd></dl>

</div>
</div>
<a id="gab0f7c39956697c400992558431e490ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab0f7c39956697c400992558431e490ac">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S , typename Transform &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::transform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Transform&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Transforms the elements of a span with a <code>function</code>. </p>
<dl class="section see"><dt>See also</dt><dd>reverse </dd>
<dd>
shuffle </dd>
<dd>
sort </dd></dl>

<p class="reference">Referenced by <a class="el" href="group__memory.html#gab0f7c39956697c400992558431e490ac">eagine::memory::transform()</a>.</p>

</div>
</div>
<a id="ga6254cac01c4e968e5f66286a0f3d02b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6254cac01c4e968e5f66286a0f3d02b2">&#9670;&nbsp;</a></span>write_to_stream()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Output , typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto write_to_stream </td>
          <td>(</td>
          <td class="paramtype">Output &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">memory::basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt; auto&amp; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for raw-reading spans into output streams. </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__memory.html#ga1b0b92acd6ef6c1e9bb9f1a1d932d29b" title="Helper function for raw-reading spans from output streams.">read_from_stream</a> </dd>
<dd>
<a class="el" href="group__memory.html#ga74307132ffa2433252a52cb23c47443e" title="Helper function for pretty-printing spans as lists into output streams.">list_to_stream</a> </dd></dl>

</div>
</div>
<a id="ga04fe3ced764ad3fdf87bf32716910454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga04fe3ced764ad3fdf87bf32716910454">&#9670;&nbsp;</a></span>zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename P , typename S &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static auto eagine::memory::zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt; T, P, S &gt;&#160;</td>
          <td class="paramname"><em>spn</em></td><td>)</td>
          <td> -&gt; std::enable_if_t&lt;
  std::is_integral_v&lt;T&gt; || std::is_floating_point_v&lt;T&gt;,
  <a class="el" href="classeagine_1_1memory_1_1basic__span.html">basic_span</a>&lt;T, P, S&gt;&gt; </td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills a span with zero value of type T. </p>
<dl class="section see"><dt>See also</dt><dd>copy </dd>
<dd>
fill </dd>
<dd>
generate </dd></dl>
<dl class="section examples"><dt>Examples</dt><dd><a class="el" href="eagine_2message_bus_2005_byte_histogram_8cpp-example.html#a0">eagine/message_bus/005_byte_histogram.cpp</a>, and <a class="el" href="eagine_2message_bus_2007_ping_8cpp-example.html#a1">eagine/message_bus/007_ping.cpp</a>.</dd>
</dl>

<p class="reference">Referenced by <a class="el" href="classeagine_1_1math_1_1bezier__curves.html#a78fb610bd27a627e291437f95d00d3fc">eagine::math::bezier_curves&lt; Type, Parameter, 3 &gt;::position01()</a>, <a class="el" href="classeagine_1_1timeout.html#a41346ba5fd3c50b5a492ef6ce4770015">eagine::timeout::reset()</a>, <a class="el" href="classeagine_1_1timeout.html#a2bbfc3e652d9a63a9c7fdf10e6cdca53">eagine::timeout::timeout()</a>, and <a class="el" href="classeagine_1_1math_1_1bezier__curves.html#afe1c9d51571a7e8e3cf66caa5b923793">eagine::math::bezier_curves&lt; Type, Parameter, 3 &gt;::wrap()</a>.</p>

</div>
</div>
</div><!-- contents -->
<br/>
<div id="oglplus-bottom">
<em>Copyright &copy; 2015-2021</em> <strong>Mat Chochlk</strong>.<br/>
&lt;<a href="mailto:chochlik@gmail.com">chochlik -at -gmail.com</a>&gt;<br/>
Documentation generated on Tue Apr 13 2021 by <a href="http://www.doxygen.org/index.html">Doxygen</a> (version 1.8.17).
</div> <!-- oglplus-bottom -->
</div> <!-- oglplus-content -->
</div> <!-- oglplus-frame -->
</body>
</html>
